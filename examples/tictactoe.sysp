;;; Tic Tac Toe in sysp — proof of concept
;;; Compiles to C, uses raylib for graphics

(use raylib)

;; Game enums
(enum Square [EMPTY 0] [X_PIECE 1] [O_PIECE 2])
(enum Player [PLAYER_X 0] [PLAYER_O 1])
(enum GameState [PLAYING 0] [WON 1] [DRAW 2])

;; Constants
(let WINDOW_SIZE :int 600)
(let CELL_SIZE :int 200)
(let LINE_THICK :int 4)
(let LEFT_CLICK :int 0)
(let FLAG_MSAA :int 32)

;; Check if a player has won. Returns the winning Square or EMPTY.
(defn check-winner [board :ptr-int] :int
  ;; Rows
  (for [i 0 3]
    (let idx (* i 3))
    (when (and (!= (array-ref board idx) EMPTY)
              (== (array-ref board idx) (array-ref board (+ idx 1)))
              (== (array-ref board idx) (array-ref board (+ idx 2))))
      (return (array-ref board idx))))
  ;; Columns
  (for [j 0 3]
    (when (and (!= (array-ref board j) EMPTY)
              (== (array-ref board j) (array-ref board (+ j 3)))
              (== (array-ref board j) (array-ref board (+ j 6))))
      (return (array-ref board j))))
  ;; Diagonals
  (when (and (!= (array-ref board 0) EMPTY)
            (== (array-ref board 0) (array-ref board 4))
            (== (array-ref board 0) (array-ref board 8)))
    (return (array-ref board 0)))
  (when (and (!= (array-ref board 2) EMPTY)
            (== (array-ref board 2) (array-ref board 4))
            (== (array-ref board 2) (array-ref board 6)))
    (return (array-ref board 2)))
  EMPTY)

;; Check if board is full
(defn board-full [board :ptr-int] :int
  (for [i 0 9]
    (when (== (array-ref board i) EMPTY)
      (return 0)))
  1)

;; Draw an X in a cell
(defn draw-x [col :int, row :int, color :Color] :void
  (let pad 30)
  (let x1 (+ (* col CELL_SIZE) pad))
  (let y1 (+ (* row CELL_SIZE) pad))
  (let x2 (- (* (+ col 1) CELL_SIZE) pad))
  (let y2 (- (* (+ row 1) CELL_SIZE) pad))
  (DrawLineEx (Vector2 (cast :f32 x1) (cast :f32 y1))
              (Vector2 (cast :f32 x2) (cast :f32 y2))
              (cast :f32 LINE_THICK) color)
  (DrawLineEx (Vector2 (cast :f32 x2) (cast :f32 y1))
              (Vector2 (cast :f32 x1) (cast :f32 y2))
              (cast :f32 LINE_THICK) color))

;; Draw an O in a cell
(defn draw-o [col :int, row :int, color :Color] :void
  (let cx (cast :f32 (+ (* col CELL_SIZE) (/ CELL_SIZE 2))))
  (let cy (cast :f32 (+ (* row CELL_SIZE) (/ CELL_SIZE 2))))
  (let radius (cast :f32 (- (/ CELL_SIZE 2) 30)))
  (let half-thick (cast :f32 (/ LINE_THICK 2)))
  (DrawRing (Vector2 cx cy) (- radius half-thick) (+ radius half-thick)
            0.0 360.0 36 color))

;; Draw the grid lines
(defn draw-grid [color :Color] :void
  (let thick (cast :f32 LINE_THICK))
  (let size (cast :f32 WINDOW_SIZE))
  (let c1 (cast :f32 CELL_SIZE))
  (let c2 (cast :f32 (* CELL_SIZE 2)))
  ;; Vertical
  (DrawLineEx (Vector2 c1 0.0) (Vector2 c1 size) thick color)
  (DrawLineEx (Vector2 c2 0.0) (Vector2 c2 size) thick color)
  ;; Horizontal
  (DrawLineEx (Vector2 0.0 c1) (Vector2 size c1) thick color)
  (DrawLineEx (Vector2 0.0 c2) (Vector2 size c2) thick color))

;; Main
(defn main [] :int
  (SetConfigFlags FLAG_MSAA)
  (InitWindow WINDOW_SIZE WINDOW_SIZE "sysp — Tic Tac Toe")
  (SetTargetFPS 60)

  (let board (make-array :int 9))
  (let-mut turn :int PLAYER_X)
  (let-mut state :int PLAYING)
  (let-mut winner :int EMPTY)

  (let white (Color 245 245 245 255))
  (let dark-bg (Color 0 0 0 255))
  (let red (Color 230 41 55 255))
  (let blue (Color 0 121 241 255))
  (let overlay (Color 0 0 0 200))

  (while (not (WindowShouldClose))
    ;; Input
    (if (== state PLAYING)
      (when (IsMouseButtonPressed LEFT_CLICK)
        (let mouse (GetMousePosition))
        (let col (cast :int (/ mouse.x (cast :f32 CELL_SIZE))))
        (let row (cast :int (/ mouse.y (cast :f32 CELL_SIZE))))
        (when (and (>= col 0) (< col 3) (>= row 0) (< row 3))
          (let idx (+ (* row 3) col))
          (when (== (array-ref board idx) EMPTY)
            (array-set! board idx (if (== turn PLAYER_X) X_PIECE O_PIECE))
            (set! winner (check-winner board))
            (if (!= winner EMPTY)
              (set! state WON)
            else
              (if (board-full board)
                (set! state DRAW)
              else
                (set! turn (if (== turn PLAYER_X) PLAYER_O PLAYER_X)))))))
    else
      ;; Game over: reset on click
      (when (IsMouseButtonPressed LEFT_CLICK)
        (for [i 0 9]
          (array-set! board i EMPTY))
        (set! turn PLAYER_X)
        (set! state PLAYING)
        (set! winner EMPTY)))

    ;; Draw
    (BeginDrawing)
    (ClearBackground dark-bg)
    (draw-grid white)

    (for [i 0 9]
      (let col (mod i 3))
      (let row (/ i 3))
      (cond
        [(== (array-ref board i) X_PIECE) (draw-x col row red)]
        [(== (array-ref board i) O_PIECE) (draw-o col row blue)]))

    (when (== state PLAYING)
      (if (== turn PLAYER_X)
        (DrawText "X's turn" 10 570 20 red)
      else
        (DrawText "O's turn" 10 570 20 blue)))

    (when (!= state PLAYING)
      (DrawRectangle 0 0 WINDOW_SIZE WINDOW_SIZE overlay)
      (cond
        [(== winner X_PIECE) (DrawText "X Wins!" 180 250 60 red)]
        [(== winner O_PIECE) (DrawText "O Wins!" 180 250 60 blue)]
        [else (DrawText "Draw!" 210 250 60 white)])
      (DrawText "Click to play again" 150 350 30 white))

    (EndDrawing))

  (CloseWindow)
  0)
