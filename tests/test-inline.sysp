;;; Test: deftype, union types, and recur together

;; Simple type aliases
(deftype Nat :int)
(deftype Real :float)

;; Union type with constructors
(deftype NumVal (:union :int :float))

;; GCD using recur â€” no dummy return
(defn gcd [a :Nat, b :Nat] :Nat
  (if (== b 0)
    a
    (recur b (% a b))))

;; Collatz sequence length using recur
(defn collatz-len [n :int, steps :int] :int
  (if (== n 1)
    steps
    (if (== (% n 2) 0)
      (recur (/ n 2) (+ steps 1))
      (recur (+ (* 3 n) 1) (+ steps 1)))))

;; Union wrapping
(defn wrap-int [x :int] :NumVal
  (NumVal-from-int x))

(defn wrap-float [x :float] :NumVal
  (NumVal-from-float x))

(defn unwrap-int [v :NumVal] :int
  (as :int v))

(defn main [] :int
  ;; Type aliases
  (println (gcd 48 18))           ;; 6
  (println (gcd 100 75))          ;; 25

  ;; Recur in nested if
  (println (collatz-len 27 0))    ;; 111

  ;; Union types
  (let v :NumVal (wrap-int 42))
  (println (runtype v))           ;; 0 (TAG_INT)
  (println (unwrap-int v))        ;; 42

  (let w :NumVal (wrap-float 2.5))
  (println (runtype w))           ;; 1 (TAG_FLOAT)
  0)
